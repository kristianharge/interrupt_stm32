/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     14/02/2022 18:07:55
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include <stdbool.h>
#include "stm32f0xx_hal.h"

#define NUM_GPIOS				16

typedef enum {
	TRIGGER_MODE_RISING=0,
	TRIGGER_MODE_FALLING=1,
	TRIGGER_MODE_BOTH=2
} TRIGGER_MODES;

void (*callback_func[NUM_GPIOS])(void);
bool enabled_callbacks[NUM_GPIOS];
uint16_t gpiopins[NUM_GPIOS] = {
 GPIO_PIN_0,
 GPIO_PIN_1,
 GPIO_PIN_2,
 GPIO_PIN_3,
 GPIO_PIN_4,
 GPIO_PIN_5,
 GPIO_PIN_6,
 GPIO_PIN_7,
 GPIO_PIN_8,
 GPIO_PIN_9,
 GPIO_PIN_10,
 GPIO_PIN_11,
 GPIO_PIN_12,
 GPIO_PIN_13,
 GPIO_PIN_14,
 GPIO_PIN_15
};
//0 -> rising edge, 1 -> falling edge, 2 -> both
uint8_t  trigger_mode[NUM_GPIOS];
TIM_HandleTypeDef htim1;

/** Functions ----------------------------------------------------------------*/
void init_GPIO_interrupt(uint16_t GPIOPin, uint32_t triggerMode, uint32_t PreemptPriority, uint32_t SubPriority){
	GPIO_InitTypeDef GPIO_InitStruct;

	GPIO_InitStruct.Pin = GPIOPin;
	GPIO_InitStruct.Mode = triggerMode;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	if(GPIOPin > 3){
		HAL_NVIC_SetPriority(EXTI4_15_IRQn, PreemptPriority, SubPriority);
		HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
	}
	else if(GPIOPin > 1){
		HAL_NVIC_SetPriority(EXTI2_3_IRQn, PreemptPriority, SubPriority);
		HAL_NVIC_EnableIRQ(EXTI2_3_IRQn);
	}
	else {
		HAL_NVIC_SetPriority(EXTI0_1_IRQn, PreemptPriority, SubPriority);
		HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
	}

	if(triggerMode == GPIO_MODE_IT_RISING){
		trigger_mode[GPIOPin] = TRIGGER_MODE_RISING;
	}
	else if(triggerMode == GPIO_MODE_IT_FALLING){
		trigger_mode[GPIOPin] = TRIGGER_MODE_FALLING;
	}
	else if(triggerMode == GPIO_MODE_IT_RISING_FALLING){
		trigger_mode[GPIOPin] = TRIGGER_MODE_BOTH;
	}
}

int debounceFilterTimerInit(uint32_t period_us){
	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
	TIM_MasterConfigTypeDef sMasterConfig = {0};

	htim1.Instance = TIM1;
	htim1.Init.Prescaler = 0;
	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim1.Init.Period = 65535;
	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	//we multiply the period with the frequency of the clock. Here 8 MHz
	htim1.Init.RepetitionCounter = period_us*8 - 1;
	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
	{
		return -1;
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
	{
		return -1;
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
	{
		return -1;
	}
}

int createCallback(uint16_t GPIOPin, void (*callback)(void)){
	if(GPIOPin >= NUM_GPIOS || GPIOPin < 0){
		return -1;
	}

	if(callback == NULL){
		return -1;
	}

	callback_func[GPIOPin] = callback;
	enabled_callbacks[GPIOPin] = 1;

	return 1;
}

int disableCallback(uint16_t GPIOPin){
	if(GPIOPin >= NUM_GPIOS || GPIOPin < 0){
		return -1;
	}

	enabled_callbacks[GPIOPin] = 0;

	return 1;
}

void EXTI4_15_IRQHandler(void){
	HAL_TIM_Base_Start_IT(&htim1);
}

void EXTI2_3_IRQHandler(void){
	HAL_TIM_Base_Start_IT(&htim1);
}

void EXTI0_1_IRQHandler(void){
	HAL_TIM_Base_Start_IT(&htim1);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	UNUSED(htim);

	for(int i = 2; i < NUM_GPIOS; i++){
		if(enabled_callbacks[i]){
			//check if the interrupt really happened
			if(trigger_mode[i] == TRIGGER_RISING){
				//used a read gpio mockup function to get the gpio value
				if(read_gpio(trigger_mode[i]) == GPIO_PIN_RESET){
					//we exit because it a debouncing error
					return;
				}
			}
			//check if the interrupt really happened
			if(trigger_mode[i] == TRIGGER_FALLING){
				//used a read gpio mockup function to get the gpio value
				if(read_gpio(trigger_mode[i]) == GPIO_PIN_SET){
					//we exit because it a debouncing error
					return;
				}
			}
			if(__HAL_GPIO_EXTI_GET_FLAG(gpiopins[i])){
				(*callback_func)();
				HAL_GPIO_EXTI_IRQHandler(gpiopins[i]);
			}
		}
	}
}


